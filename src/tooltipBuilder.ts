/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
import powerbi from "powerbi-visuals-api";
import DataView = powerbi.DataView;

// powerbi.extensibility.utils.formatting
import {valueFormatter} from "powerbi-visuals-utils-formattingutils";

import DataViewValueColumn = powerbi.DataViewValueColumn;
import DataViewCategorical = powerbi.DataViewCategorical;
import DataViewMetadataColumn = powerbi.DataViewMetadataColumn;
import PrimitiveValue = powerbi.PrimitiveValue;
import VisualTooltipDataItem = powerbi.extensibility.VisualTooltipDataItem;
import ILocalizationManager = powerbi.extensibility.ILocalizationManager;

const HighlightedValueDisplayName: string = "Visual_Tooltips_Highlighted";
const VisualTooltipsValues: string = "Visual_Values";
const DefaultSeriesIndex: number = 0;
const TooltipsRoleName = "Tooltips";

type RolesMap = { [key: string]: boolean } | undefined;

export interface TooltipSeriesDataItem {
    value?: unknown;
    highlightedValue?: unknown;
    metadata: DataViewValueColumn;
}

/**
 * Creates tooltip items for the visual.
 * Behavior:
 * - If explicit tooltip fields exist (Tooltips role on category/value columns), returns ONLY those tooltip items.
 * - Else falls back to the default series tooltips created via createTooltipData.
 */
export function createTooltipInfo(
    dataView: DataView,
    dataViewCat: DataViewCategorical,
    localizationManager: ILocalizationManager,
    seriesIndex?: number,
    categoryIndex?: number
): VisualTooltipDataItem[] {
    const resolvedSeriesIndex = resolveSeriesIndex(seriesIndex);
    const hasValidCategoryIndex = isValidCategoryIndex(categoryIndex);

    const tooltipColumns = collectExplicitTooltipColumns(dataViewCat);

    // Explicit tooltips mode (Tooltips role exists on categories or values)
    if (tooltipColumns.hasAny) {
        return buildExplicitTooltipItems({
            dataViewCat,
            tooltipCategoryColumns: tooltipColumns.categoryColumns,
            tooltipValueColumns: tooltipColumns.valueColumns,
            seriesIndex: resolvedSeriesIndex,
            categoryIndex,
            hasValidCategoryIndex
        });
    }

    // Default tooltips mode (no explicit tooltip fields)
    const seriesSource: TooltipSeriesDataItem[] = [];
    const valuesSource: DataViewMetadataColumn | undefined = dataViewCat?.values?.source;

    const valueColumns = dataViewCat?.values;
    if (valueColumns && valueColumns.length > 0) {
        const valueColumn: DataViewValueColumn = valueColumns[resolvedSeriesIndex];
        const isAutoGeneratedColumn = !!(valueColumn?.source && (valueColumn.source as any).isAutoGeneratedColumn);

        if (!isAutoGeneratedColumn && valueColumn) {
            seriesSource.push({
                value: null,
                highlightedValue: undefined,
                metadata: valueColumn
            });
        }
    }

    return createTooltipData(dataView, valuesSource, seriesSource, localizationManager);
}

export function createTooltipData(
    dataView: DataView,
    valuesSource: DataViewMetadataColumn | undefined,
    seriesValues: TooltipSeriesDataItem[],
    localizationManager: ILocalizationManager
): VisualTooltipDataItem[] {
    const items: VisualTooltipDataItem[] = [];

    // Dynamic series value
    if (valuesSource) {
        let dynamicValue: string | undefined;

        if (seriesValues.length > 0) {
            const dynamicValueMetadata: DataViewMetadataColumn = seriesValues[0].metadata.source;
            dynamicValue = getFormattedValue(valuesSource, dynamicValueMetadata.groupName);
        }

        items.push({
            displayName: valuesSource.displayName,
            value: dynamicValue
        });
    }

    for (let index = 0; index < seriesValues.length; index++) {
        const seriesData = seriesValues[index];
        if (!seriesData?.metadata?.source) {
            continue;
        }

        const seriesMetadataColumn = seriesData.metadata.source;
        const value = seriesData.value;
        const highlightedValue = seriesData.highlightedValue;

        if (value || value === 0) {
            items.push({
                displayName: seriesMetadataColumn.displayName,
                value: getFormattedValue(seriesMetadataColumn, value)
            });
        }

        if (highlightedValue || highlightedValue === 0) {
            items.push({
                displayName: localizationManager.getDisplayName(HighlightedValueDisplayName),
                value: getFormattedValue(seriesMetadataColumn, highlightedValue)
            });
        }

        // NOTE: Keeping the original logic and output format intact:
        // - If highlights exist, take non-null highlights values and join with spaces.
        // - Else join values with spaces.
        if (seriesData.metadata.values) {
            let valuesList: string;

            if (seriesData.metadata.highlights) {
                valuesList = seriesData.metadata.highlights
                    .filter(d => (d === null ? false : true))
                    .join(" ");
            } else {
                valuesList = seriesData.metadata.values.join(" ");
            }

            items.push({
                displayName: localizationManager.getDisplayName(VisualTooltipsValues),
                value: valuesList
            });
        }
    }

    return items;
}

export function getFormattedValue(column: DataViewMetadataColumn, value: unknown): string {
    const formatString = getFormatStringFromColumn(column);
    return valueFormatter.format(value as any, formatString);
}

export function getFormatStringFromColumn(column: DataViewMetadataColumn): string | null {
    if (!column) {
        return null;
    }

    const formatString = valueFormatter.getFormatStringByColumn(column, true);
    return formatString || column.format;
}

function resolveSeriesIndex(seriesIndex?: number): number {
    // Keep original behavior: bitwise OR with DefaultSeriesIndex.
    // (If seriesIndex is undefined, result is 0)
    return (seriesIndex as any) | DefaultSeriesIndex;
}

function isValidCategoryIndex(categoryIndex?: number): categoryIndex is number {
    return categoryIndex !== undefined && categoryIndex >= 0;
}

function hasTooltipsRole(roles?: RolesMap): boolean {
    return !!(roles && roles[TooltipsRoleName]);
}

function collectExplicitTooltipColumns(dataViewCat: DataViewCategorical | undefined): {
    categoryColumns: powerbi.DataViewCategoryColumn[];
    valueColumns: DataViewValueColumn[];
    hasAny: boolean;
} {
    const categoryColumns = dataViewCat?.categories
        ? dataViewCat.categories.filter(categoryColumn => hasTooltipsRole(categoryColumn?.source?.roles as any))
        : [];

    const valueColumns = dataViewCat?.values
        ? (dataViewCat.values as DataViewValueColumn[]).filter(valueColumn => hasTooltipsRole(valueColumn?.source?.roles as any))
        : [];

    return {
        categoryColumns,
        valueColumns,
        hasAny: categoryColumns.length > 0 || valueColumns.length > 0
    };
}

function buildExplicitTooltipItems(args: {
    dataViewCat: DataViewCategorical;
    tooltipCategoryColumns: powerbi.DataViewCategoryColumn[];
    tooltipValueColumns: DataViewValueColumn[];
    seriesIndex: number;
    categoryIndex?: number;
    hasValidCategoryIndex: boolean;
}): VisualTooltipDataItem[] {
    const {
        dataViewCat,
        tooltipCategoryColumns,
        tooltipValueColumns,
        seriesIndex,
        categoryIndex,
        hasValidCategoryIndex
    } = args;

    const items: VisualTooltipDataItem[] = [];
    const addedTooltipKeys = new Set<string>();

    const currentSeriesColumn = getSeriesColumn(dataViewCat, seriesIndex);
    const currentSeriesGroupName: PrimitiveValue | undefined = currentSeriesColumn?.source?.groupName;

    const addTooltipItem = (column: DataViewMetadataColumn | undefined, value: PrimitiveValue): void => {
        if (!column || value === null || value === undefined) {
            return;
        }

        const displayName = column.displayName;
        const formattedValue = getFormattedValue(column, value);
        const queryName = column.queryName || displayName;

        // Keep original uniqueness rule
        const tooltipKey = `${queryName}::${formattedValue}`;
        if (addedTooltipKeys.has(tooltipKey)) {
            return;
        }

        addedTooltipKeys.add(tooltipKey);
        items.push({ displayName, value: formattedValue });
    };

    // Keep original behavior:
    // If tooltip fields exist but categoryIndex is invalid, return what we have so far (empty)
    if (!hasValidCategoryIndex) {
        return items;
    }

    // Tooltip category columns (Tooltips role)
    for (const tooltipCategoryColumn of tooltipCategoryColumns) {
        if (!tooltipCategoryColumn?.source || !tooltipCategoryColumn.values) {
            continue;
        }

        addTooltipItem(tooltipCategoryColumn.source, tooltipCategoryColumn.values[categoryIndex!]);
    }

    // Tooltip value columns (Tooltips role)
    for (const tooltipColumn of tooltipValueColumns) {
        if (!tooltipColumn?.source) {
            continue;
        }

        // Keep original filter: only include value columns that match current series group name (if both exist)
        const tooltipGroupName: PrimitiveValue = tooltipColumn.source.groupName;

        if (currentSeriesGroupName !== null
            && currentSeriesGroupName !== undefined
            && tooltipGroupName !== null
            && tooltipGroupName !== undefined
            && tooltipGroupName !== currentSeriesGroupName) {
            continue;
        }

        const tooltipValue = tooltipColumn.values ? tooltipColumn.values[categoryIndex!] : undefined;
        addTooltipItem(tooltipColumn.source, tooltipValue);
    }

    return items;
}

function getSeriesColumn(dataViewCat: DataViewCategorical | undefined, seriesIndex: number): DataViewValueColumn | undefined {
    const values = dataViewCat?.values;
    if (!values || seriesIndex < 0 || seriesIndex >= values.length) {
        return undefined;
    }
    return values[seriesIndex];
}
